---
layout: post
title:  "Puzzle Post 1: Probabilities at Brunch"
date:   2022-04-07 11:16:42 +0000
tags: Puzzles
---

Welcome to the first puzzle post! Each of these will be a related collection of math questions which I find particularly fun to think about.

Today's questions will be about simulating biased probabilities with a fair coin.

Suppose that one Sunday, you are getting brunch and are trying to decide between getting a croissant and a waffle. Being indecisive, you notice you have a coin in your pocket and decide to leave your choice up to fate. However, you do like waffles a little better.

> Using only the results from a fair coin, how could you choose the croissant with probability \\(1/3\\) and the waffle with probability \\(2/3\\)?


<details markdown=1> <summary> Solution </summary>
There are many ways we can go about this. One possibility is as follows:
In each step, flip the coin twice. Choose the following: 

+ **TT** \\(\rightarrow\\) *Croissant* 
+ **HT** \\(\rightarrow\\) *Waffle* 
+ **HH** \\(\rightarrow\\) *Waffle* 
+ **TH** \\(\rightarrow\\) Flip the coin twice again, and choose the pastry corresponding to the new pair of flips. If **TH** is flipped again, keep repeating this process until a choice is made.

The probability that we still have not made a choice after \\(n\\) steps is 
\\(\left(\frac{1}{4}\right)^n\\), so eventually we must choose with probability 1. By symmetry, we see that the there is an equal chance for the last two flips to be **TT**, **HT**, or **HH**. Thus, there is a \\(1/3\\) chance that the last two flips were **TT** and that *Croissant* is chosen.
</details>

<br/>

> Could you choose the croissant with probability \\(\frac{1}{\pi}\\)?

<details markdown=1> <summary> Solution </summary>

 The answer is yes! Consider the following perspective. Think of the sequence of coin flips as generating an infinite binary decimal, with **T** corresponding to the digit \\(0\\) and **H** corresponding to the digit \\(1\\). For example, **THTHHTTTTH...** would correspond to

$$
\begin{array}{ c c c c c c c c c c c c }
    &T&H&T&H &H &T &T &T &H &\dots\\
    0.&0&1&0&1 &1 &0 &0 &0 &1 &\dots
\end{array}
$$

 We can interpret our algorithm from above as choosing *croissant* exactly when the corresponding binary decimal is less than \\[\frac{1}{3} = 0.01010101\dots .\\]
 
 This is because:
 + If the first two flips are **TT**, then our binary decimal begins with \\(0.00\dots \\) and so must be less than \\(0.0101\dots.\\) 
 + On the other hand, if our first flip is **H**, then our binary decimal begins with \\(0.1\dots\\) and is thus already bigger than \\(0.0101\dots\\). 
 + If our first two flips are **TH**, then we can't tell at this point and must flip again.
 
 It is not to hard to see that this sort of algorithm works for *any* probability \\(p \in [0,1]\\). Since the binary decimal generated by our coin is uniformly distributed in \\([0,1]\\), we can simply choose *croissant* when the binary decimal is less than \\(p\\) and *waffle* otherwise.

<br/>

 In general, we can return a value as soon as our binary decimal differs from the binary decimal expansion of \\(p\\). For example, \\(1/\pi\\) in binary is \\[1/\pi = 0.01010001011\dots .\\] 
 If our first flip is **H**, then we immediately know that our decimal is larger than \\(1/\pi\\). 

$$
\begin{array}{ c c c c c c}
    1/\pi =& 0.&0 &1 &0 &1 &0 &\dots \\
    \text{Coin flip results:}&  &1 \\
    &  &\downarrow
\end{array}
$$
 
 On the other hand, if our first flip is **T** but our second flip is also **T**, then we know that our decimal must be smaller than \\(1/\pi\\).

$$
\begin{array}{ c c c c c c}
    1/\pi =& 0.&0 &1 &0 &1 &0 &\dots \\
    \text{Coin flip results:}&  &0 &0 \\
    &  &  &\downarrow
\end{array}
$$

 The rule is as follows: if the decimal expansion of \\(p\\) has a \\(0\\) and we flip \\(1\\) in the corresponding position, return *waffle*; if the decimal expansion of \\(p\\) has a \\(1\\) and we flip \\(0\\) in the corresponding position, return *croissant*. 

 Since there is only a \\(1/2\\) chance of agreeing with \\(p\\) in each decimal place, the expected number of flips is \\[\sum_{n=1}^\infty n \cdot \mathbb{P}(\text{exactly }n\text{ flips needed}) = \sum_{n=1}^\infty n \cdot \left(\frac{1}{2^n} \right) = 2.\\] 
 
 This value is independent of the desired probability \\(p\\)!

</details>

<br/>

> Is there an algorithm which lets you choose the croissant with probability \\(p \in (0, 1)\\) in less than 2 expected flips, for any \\(p\\) not of the form \\(\frac{a}{2^n}\\)? 

<details markdown=1> <Summary> Solution </Summary>
 
 The answer turns out to be no, that 2 expected flips is optimal for any real number not of the form \\(\frac{a}{2^n}\\). 
 
 This is a question that came up naturally as I was writing this post, and while searching for an answer I came across this <a href="https://www.alexirpan.com/2015/08/23/simulating-a-biased-coin-with-a-fair-one.html" class="blog-link">blog post</a> by Alex Irpan which has a wonderfully written solution. Rather than copy it here, I'll direct you to his post! 

</details>

